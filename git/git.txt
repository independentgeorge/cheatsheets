
reporting
---------

  git help <topic>                          # Open manual page for <topic>.

  git status                                # Show the checked out branch and its relation to the upstream branch, show paths that have differences between the staging area and HEAD, between staging and working areas, and show paths not tracked.
  git status <path>                         # Show status of <path>, as opposed to entire repository.
  git status -s                             # Show status compactly.
  git status -u                             # List individual untracked files (as opposed to directories).

  git ls-files                              # List staged files.
  git ls-files -s                           # List staged files along with mode bits, object name and stage number.
  git ls-files -u                           # List unsuccessfully merged files.

  git diff                                  # Show what was changed but not yet staged in all tracked files.
  git diff <path>                           # Show what was changed but not yet staged in tracked file(s) at <path>.
  git diff --cached                         # Show what was staged but not yet commited.
  git diff <commit1>..<commit2>             # Show the differences between <commit1> and <commit2> for every file in either one.
  git difftool                              # Use an external tool for `git diff`, with the same options and arguments.

  git log                                   # Show commit logs preceding (and including) HEAD.
  git log <range>                           # Show commit logs in the commit <range>.
  git log --stat                            # Show an overview of file edits in each commit.
  git log --abbrev-commit                   # Show checksums in short form.
  git log --relative-date                   # Show dates in format relative to now.
  git log --decorate                        # Show branches/tags next to commits.
  git log --graph                           # ASCII representation of branches and merges.
  git log --all                             # Include all branches.
  git log --pretty=format:"<pattern>"       # Use custom format, see `git help log` for details.

  git log <path>                            # Show commits that introduced a change to file(s) at <path>.
  git log -<n>                              # Show last <n> entries where <n> is an integer.
  git log --since=<date>                    # Show commits created after the date (in absolute or relative form). Alternatively use `--after`.
  git log --until=<date>                    # Show commits created before the date (in absolute or relative form). Alternatively use `--before`.
  git log --author=<name>                   # Show commits whose author is <name>.
  git log --committer=<name>                # Show commits whose committer is <name>.
  git log --grep <regex>                    # Show commits whose contents matches <regex>.
  git log -S<string>                        # Show commits that add or remove <string>.
  git log -G<regex>                         # Show commits that add or remove lines that match <regex>.
  git log --all-match                       # Match all filters, not any.

  git reflog                                # Show local history of HEAD's tip updates. Alias for `git log --walk-reflogs --abbrev-commit --pretty=oneline`.
  git reflog <branch>                       # Show local history of <branch>'s tip updates.

  git blame <file>                          # Show commit, author and date of last modification for each line of <file>.

  git rev-parse <object>                    # Return the corresponding SHA-1 string of <object>.


repositories
------------

  git init                                  # Create a new .git repository at the current path. Create and check out a branch named `master`.
  git init <path>                           # Initialise a repository at <path>.
  git init --bare                           # Initialise a bare .git repository (one without a working area).

  git clone <path> [<name>]                 # Get a copy of an existing .git repository. Create a remote for <path> named `origin`, create and checkout a branch that tracks the remote HEAD.
  git clone <path> <name>                   # Clone under a different name.
  git clone --bare <path>                   # Clone as bare. By convention, their names end in .git.
  git clone --origin <remote> <path>        # Clone and use a different name for the remote instead of `origin`.
  git clone --recursive <path>              # Clone the repository, initialise and update submodules.

  git submodule add <path>                  # Clone a .git repository at <path> as a submodule under a directory named as the repository.
  git submodule add <path> <name>           # Clone a .git repository at <path> as a submodule under a directory named <name>.
  git submodule init                        # Initialise all submodules listed in .gitmodules.

  git submodule deinit <path>               # Remove submodule entry from .git/config.
  rm -rf .git/modules/<path>                # Remove submodule directory from the superproject's .git/modules.
  git rm -f <path>                          # Remove submodule entry in .gitmodules and remove its directory at <path>.

  git mv <old> <new>                        # Move submodule directory and update .gitmodules.

  git submodule status                      # Show the status of submodules.


files & commits
---------------

  git add <path> ...                        # Add file or directory to the staging area.
  git add -p <path>                         # Partial (--patch) staging.

  git rm <path> ...                         # Remove a file from the staging and working areas if no data is lost.
  git rm -f <path>                          # Remove a file from the staging and working areas.
  git rm --cached <path>                    # Remove a file from the staging area.
  git rm -r <path>                          # Remove a file or directory recursively.

  git mv <old> <new>                        # Rename a file in the staging and working areas.

  git commit                                # Create a new commit with the contents of the staging area, and update the checked out branch to point to it.
  git commit -m "message"                   # Type the message inline.
  git commit --amend                        # Overwrite previous commit.

  git reset <commit> <file>                 # Revert the file in the staging area to what it's like in <commit>, leaving the working area intact.
  git checkout <commit> <file>              # Revert the file in the working area to what it's like in <commit>, overwriting local changes without warning.

  git clean -n                              # Show which files would be cleaned.
  git clean -f                              # Delete untracked files.
  git clean -d                              # Delete untracked files and directories.
  git clean -x                              # Delete untracked and ignored files.
  git clean -i                              # Clean interactively.


branches
--------

  git branch                                # List local branches.
  git branch -r                             # List remote branches.
  git branch -a                             # List local and remote branches.
  git branch -vv                            # List branches and the upstream branches they track, along with the matching commit.
  git branch --merged <commit>              # List branches reachable from <commit>, which defaults to HEAD.
  git branch --no-merged <commit>           # List branches not reachable from <commit>, which defaults to HEAD.

  git branch <name>                         # Create a new branch pointing to HEAD.
  git branch <name> <commit>                # Create a new branch pointing to <commit>.
  git branch -m <name>                      # Rename checked out branch.
  git branch -m <old> <new>                 # Rename specified branch.
  git branch -d <branch>                    # Delete a branch.
  git branch -dr <remote/branch>            # Delete a remote-tracking branch.
  git branch -f <branch> <commit>           # Move branch tip to <commit>.

  git checkout <branch>                     # Make HEAD point to <branch>'s tip and update staging and working areas to match the commit. Fails if any data would be lost.
  git checkout --orphan <branch>            # Create a new branch <branch> without parents (separate histories), and check it out.
  git checkout -b <name>                    # Create a new branch <name> and check it out.
  git checkout -b <name> <remote/branch>    # Create a new branch <name> that tracks <remote/branch>, and check it out.
  
  git reset --soft <ref>                    # Make the checked out branch point to <ref>, leaving the staging and working areas intact. <ref> defaults to HEAD.
  git reset --mixed <ref>                   # Make the checked out branch point to <ref> and update the staging area, leaving the working area intact. <ref> defaults to HEAD. Default option.
  git reset --hard <ref>                    # Make the checked out branch point to <ref> and update the staging and working areas to look exactly as they are in <ref>, overwriting local changes without warning. <ref> defaults to HEAD.

  git revert <commit>                       # Make a new commit undoing the changes made since <commit>.
  git revert -m <n> <commit>                # Revert a merge commit by choosing the <n>-th parent of <commit> (where <n> is an integer, starting from 1), discarding all changes on other parents.

  git branch -u <remote/branch>             # Make the checked out branch track <remote/branch>.
  git branch -u <remote/branch> <branch>    # Make <branch> track <remote/branch>.
  git branch --unset-upstream               # Stop the checked out branch from tracking the upstream branch.
  git branch --unset-upstream <branch>      # Stop <branch> from tracking the upstream branch.


merging & rebasing
------------------

  git merge <branch>                        # Merge <branch> into the checked out branch. Introduces a new commit unless fast-forwarding.
  git merge --squash <branch>               # Merge <branch> into the checked out branch without introducing any commits.
  git merge --abort                         # Abort the active merge, when there are unresolved conflicts.

  git rebase <branch>                       # Reset checked out branch to <branch>, apply differences (between previous HEAD and the common ancestor) and commit.
  git rebase <branch1> <branch2>            # Reset <branch2> to <branch1>, apply differences (between <branch2> and the common ancestor) and commit.
  git rebase --onto <branch1> <branch2>     # Reset checked out branch to <branch1>, apply differences (between previous HEAD and <branch2>) and commit.

  git rebase -i <commit>                    # Rebase interactively, starting with the commit following <commit>.
  git rebase -i --root                      # Rebase interactively, starting with the first commit.


remotes
-------

  git remote                                # List configured remotes.
  git remote -v                             # List configured remotes with fetch/push urls.
  git remote show <remote>                  # Show information about the remote. List remote branches when used on a configured remote (and not its path).

  git remote add <remote> <path>            # Add a new remote for the repository at <path>.
  git remote rename <old> <new>             # Rename a remote.
  git remote remove <name>                  # Remove a remote.

  git ls-remote <remote>                    # List references of a remote repository without fetching.
  git ls-remote --heads <remote>            # List branches of a remote repository without fetching.
  git ls-remote --tags <remote>             # List tags of a remote repository without fetching.


fetching & pushing
------------------

  git fetch <remote> <branch>               # Download new data on <branch> from <remote> and update the remote-tracking branch.
  git fetch <remote>                        # Fetch all branches from <remote>.
  git fetch                                 # Fetch from the remote of the upstream branch, or `origin`.
  git fetch --all                           # Fetch from all remotes.
  git fetch --prune                         # Fetch and remove remote-tracking branches that no longer exist in the remote repository.
  git fetch --recurse-submodules            # Fetch all submodules (and their submodules).

  git pull <remote> <branch>                # Fetch (with same arguments) and merge <remote/branch> into the checked out branch.
  git pull                                  # Pull from the upstream branch.
  git pull --rebase                         # Fetch and rebase.

  git push <remote> <branch1>:<branch2>     # Send new commits on <branch1> to <branch2> on <remote>. Create a new branch in the remote repository if it does not exist. Only works if you have write access and all remote data is fetched locally.
  git push <remote> <branch>                # Push <branch> to <branch> on <remote>.
  git push <remote> <tag>                   # Push <tag> to <tag> on <remote>.
  git push -u <remote> <branch>             # Push <branch> and make the checked out branch track <remote/branch>.
  git push                                  # Push the checked out branch to the upstream branch, if it tracks one.
  git push --all                            # Push all branches.
  git push --tags                           # Push all tags.
  git push -f <remote> <branch1>:<branch2>  # Replace <branch2> on <remote> with <branch1>.
  git push -d <remote> <branch>             # Delete <branch> from the remote repository.
  git push --dry-run                        # Show what would be pushed.


tags
----

  git tag <name>                            # Create a lightweight tag pointing to HEAD.
  git tag <name> <commit>                   # Create a lightweight tag pointing to <commit>.
  git tag <name> -a                         # Create an annotated tag.
  git tag <name> -m "message"               # Create an annotated tag with the message inline.
  git tag <name> -d                         # Delete a tag.

  git tag                                   # List all tags.
  git tag -l <pattern>                      # List all tags containing the specified glob pattern.
  git show <tag>                            # Show information about the annotated <tag> and the related commit.


stashes
-------

  git stash list                            # List stored stashes.

  git stash                                 # Save changed tracked files in working and staging areas and checkout HEAD. Fails if any data would be lost.
  git stash -u                              # Stash untracked files too.
  git stash -a                              # Stash untracked and ignored files too.
  git stash --keep-index                    # Don't stash staged files.

  git stash apply                           # Apply the changes of the latest stash (to the working directory). This command is utterly fucked up - stashed unstaged files automatically get staged (and they overwrite files actually staged!). ALWAYS USE --index FOR EXPECTED BEHAVIOUR.
  git stash apply <n>                       # Apply the changes to files of <n>-th stash, where <n> is an integer.
  git stash apply --index                   # Apply the changes to the staging area aswell.
  
  git stash drop <n>                        # Remove the <n>-th stash.
  git stash pop                             # Apply and drop the latest stash.
  git stash branch <name>                   # Create and check out a new branch <branch> at the commit you were on when stashing and pop the stash.


honorable mentions
------------------

  git cherry-pick <commit>                  # Apply changes introduced by <commit> to checked out branch. Requires a clean working area.
  git filter-branch <command> <branch>      # Run <command> in shell after each checkout of the project and recommit the results, completely rewriting history.

